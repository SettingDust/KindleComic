<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>C#作业 - 书籍阅读器</title>
      <link href="/2018/09/29/C-%E4%BD%9C%E4%B8%9A-%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB%E5%99%A8/"/>
      <url>/2018/09/29/C-%E4%BD%9C%E4%B8%9A-%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>题目要求很简单，单页长度可设置，页数可选择<br>没有具体说明文件是内置文本还是怎么样，我选择遍历同目录txt文件，实用性更好一些<br><strong>C#运行目录在<code>bin\Debug</code></strong><br>遍历代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DirectoryInfo Folder = new DirectoryInfo(&quot;.&quot;);</span><br><span class="line">foreach (FileInfo File in Folder.GetFiles())</span><br><span class="line">&#123;</span><br><span class="line">    if (File.Extension.Equals(&quot;.txt&quot;))</span><br><span class="line">      this.listBox1.Items.Add(File.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取文件夹信息，然后遍历文件并确认文件扩展名即可，非常简单</p><hr><p>这里做了一个没必要的操作，但是，面向对象天下第一XDDD<br>不得不说C#这个命名方式让我Java出家的很是为难……（什么反人类的全部大写！C#家骆驼头抬得真高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Book</span><br><span class="line">&#123;</span><br><span class="line">    private string Name;</span><br><span class="line">    private int Current;</span><br><span class="line"></span><br><span class="line">    public Book(string Name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.Name = Name;</span><br><span class="line">        this.Current = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public string getNext()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>接下来，考虑书籍文本可能有相对较大的文本量（当然目前作业是用不到的），考虑分段读取一下文本<br>写的时候发现C#可以var变量，C#真香（虽然最后还是习惯性的都给类型了XDDD）<br>目前Book类的形状<br>顺带一提，VS的竖向选择是Alt+Shift，还是IDEA的滚轮键更好啊<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Book</span><br><span class="line">&#123;</span><br><span class="line">    private int Current;</span><br><span class="line">    private FileStream FileStream;</span><br><span class="line"></span><br><span class="line">    public Book()</span><br><span class="line">    &#123;</span><br><span class="line">        this.Current = 1;</span><br><span class="line">        this.FileStream = File.OpenRead(Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int GetCurrent()</span><br><span class="line">    &#123;</span><br><span class="line">        return this.Current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetCurrent(int Current)</span><br><span class="line">    &#123;</span><br><span class="line">        this.Current = Current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public string GetNext()</span><br><span class="line">    &#123;</span><br><span class="line">        int Length = Form1.form.GetLength();</span><br><span class="line">        Byte[] bytes = new Byte[Length];</span><br><span class="line">        FileStream.Position = Length * (Current++ - 1);</span><br><span class="line">        FileStream.Read(bytes, 0, Length);</span><br><span class="line">        return Encoding.Default.GetString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>之后需要做的是分页，很明显中文会有字符分割乱码的问题<br>大概思路就是判断开头和结尾是否被分割然后+1-1的问题<br>GB的wiki中可以看到</p><blockquote><p>“高位字节”使用了0xA1–0xF7（把01–87区的区号加上0xA0），“低位字节”使用了0xA1–0xFE（把01–94加上0xA0）。 由于一级汉字从16区起始，汉字区的“高位字节”的范围是0xB0–0xF7，“低位字节”的范围是0xA1–0xFE，占用的码位是72*94=6768。其中有5个空位是D7FA–D7FE。  </p></blockquote><hr><p>吃完饭回来搞好了，其实换一个类就可以读取字符了，我太蠢了，太不熟悉了</p><p>总结：历时5小时 效率极低</p><p><a href="链接: https://pan.baidu.com/s/1ArgkfyD0jIg6cp9iuJAQ8Q">度娘 提取码：xdka</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo首页文章显示部分</title>
      <link href="/2018/09/28/Hexo%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86/"/>
      <url>/2018/09/28/Hexo%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>Hexo首页的部分显示是通过文章之中<code>&lt;!--more--&gt;</code>来判断是否隐藏之后文本<br>网络搜寻一些方法可以实现，但是代码方面有些问题，自己实现一次，不算困难<br>这里是next主题<br>6.0之后的swig为开发带来很大困难，之前没有接触过，甚至没有开发过jade的经验，nodejs也不甚熟练<br>不过经过摸索还是成功了，可配置的显示多少行<br>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% set content = post.content %&#125;</span><br><span class="line">&#123;% set i = content.indexOf(&quot;&lt;p&gt;&quot;) %&#125;</span><br><span class="line">&#123;% set arr = [] %&#125;</span><br><span class="line">&#123;% set arr.length = theme.auto_excerpt.length %&#125;</span><br><span class="line">&#123;% for item in arr %&#125;</span><br><span class="line">  &#123;% if content.indexOf(&quot;&lt;p&gt;&quot;, i + 1) &gt; 0 %&#125;</span><br><span class="line">    &#123;% set i = content.indexOf(&quot;&lt;p&gt;&quot;, i + 1) %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% if i &lt; 0 %&#125;</span><br><span class="line">  &#123;&#123; content &#125;&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">  &#123;&#123; content.substring(0, i)&#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://pan.baidu.com/s/1NmMSDYS54xyp8vs7o8-C_Q" target="_blank" rel="noopener">度娘</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《『乙女が結ぶ月夜の煌めき』 体験版》解包记录</title>
      <link href="/2018/09/28/%E3%80%8A%E3%80%8E%E4%B9%99%E5%A5%B3%E3%81%8C%E7%B5%90%E3%81%B6%E6%9C%88%E5%A4%9C%E3%81%AE%E7%85%8C%E3%82%81%E3%81%8D%E3%80%8F-%E4%BD%93%E9%A8%93%E7%89%88%E3%80%8B%E8%A7%A3%E5%8C%85%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/09/28/%E3%80%8A%E3%80%8E%E4%B9%99%E5%A5%B3%E3%81%8C%E7%B5%90%E3%81%B6%E6%9C%88%E5%A4%9C%E3%81%AE%E7%85%8C%E3%82%81%E3%81%8D%E3%80%8F-%E4%BD%93%E9%A8%93%E7%89%88%E3%80%8B%E8%A7%A3%E5%8C%85%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>通过游戏目录的查看，可以明显发现arc文件是资源文件，猜测Rio及Rio1为文本文件。<br>首先尝试BandZip打开，明显不行23333333333</p><p>经过几个工具的测试，最终确认GARbro对新手很友好，非常容易，效果也ok，针对此游戏可用。<br>直接提取到文件夹（此处建议解压到一个新的Rio文件夹中），发现文本为ws2文件，搜索如何解包</p><p>使用Notepad++ 的HexEditor查看文件，初步怀疑文本经过加密，寻找可用工具<br>找到了FuckGalEngine项目下的ahdprc，github需要编译使用<br><strong>这里我最终使用了ahdprc命令行方式解包，但是GARbro相对没有编程基础的朋友更友好</strong></p><p>把ahdprc和Rio.ws2放到同一文件夹执行如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ahdprc arc Rio.arc -u -c</span><br><span class="line">ahdprc ror -n 2 Rio\*.ws2</span><br></pre></td></tr></table></figure></p><p>两行代码就可以，第二行为位移<br><strong>GARbro会提取之后自动位移，这也是为什么更友好的原因</strong><br>ahdprc的编译浪费了很久的时间，一个神奇的错误，最终使用了一个编译成功的exe，文章末附上</p><p>以上解包arc完成，两种方法都可以，注意我解压的Rio1，重命名为Rio，名字不对不知为什么不可以解包。当然GARbro没有这个问题</p><p>按照顺序运行如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md txt</span><br><span class="line">md bin</span><br></pre></td></tr></table></figure></p><p>创建两个文件夹  </p><p><code>for %i in (Rio\*.ws2) do ahdprc ws2 -i %i -t txt\%~ni.txt -b bin\%~nxi</code><br><strong>不是批处理哦</strong><br>注意这里，如果你是使用我上面的代码输出当然不用担心，如果没有，而且没有解压到Rio文件夹中，那就要修改Rio为你的路径了。<br>这步成功之后查看txt文件夹，翻译即可</p><p>格式就是空心原文实心译文  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for %i in (txt\*.txt) do ahdprc ws2 %i -o tf\%~nxi</span><br><span class="line">md Chs</span><br><span class="line">for %i in (bin\*.ws2) do ahdprc ws2 -b %i -t tf\%~ni.txt -o Chs\%~nxi 1&gt;&gt; log.txt</span><br></pre></td></tr></table></figure><p>此步生成的log.txt会记录具体哪些行需要在新的字体中表现出来，做替换列表</p><p><code>ahdprc rep -l rep.txt tf\*.txt</code> 做好替换列表使用此命令进行替换</p><p>替换之后再次使用<br><code>for %i in (bin\*.ws2) do ahdprc ws2 -b %i -t tf\%~ni.txt -o Chs\%~nxi 1&gt;&gt; log.txt</code><br>生成日志文件查看，循环直到正常为止  </p><p>如果解包后文件存在非ws2文件，复制到Chs文件夹中，可以手动也可以继续命令行<br><code>copy Rio\Pan.dat Chs\Pan.dat</code>  </p><p>最后一步，封包<br><code>ahdprc arc -r Chs -c</code></p><p>至此，全部完成，但是替换列表目前不太清楚是什么，需要具体操作了。  </p><p>2018/9/28 - 16:15</p>]]></content>
      
      
      <categories>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
            <tag> 技术 </tag>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
